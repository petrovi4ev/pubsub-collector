package redis_dumper

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/BitMedia-IO/RollerCoin-Go-Mining-Service/tool/files"
	"gopkg.in/redis.v3"
	"time"
)

type RedisItem struct {
	Key   string
	Type  string      `json:"type"`
	Value interface{} `json:"value"`
	TTL   int         `json:"ttl"`
}

const (
	RedisImportTypeString = "string"
	RedisImportTypeHash   = "hash"
	RedisImportTypeZset   = "zset"
	RedisImportTypeList   = "list"
)

/*
JSONImportRedisDB imports data from a Redis JSON dump file.
Dump data is generated by redis-dump (https://www.npmjs.com/package/redis-dump)
*/
func JSONImportRedisDB(gameRedisClient *redis.Client, path string) error {
	data, err := files.ReadFromFile(path)
	if err != nil {
		readError := fmt.Sprintf("Error reading file %s: %s", path, err.Error())
		return errors.New(readError)
	}
	jsonMap := make(map[string]RedisItem)
	err = json.Unmarshal(data, &jsonMap)
	if err != nil {
		return errors.New("Error while trying to deserialize json: " + err.Error())
	}

	var redisItems []*RedisItem
	for key, content := range jsonMap {
		newRedisItem := &RedisItem{Key: key, Type: content.Type, Value: content.Value, TTL: content.TTL}

		redisItems = append(redisItems, newRedisItem)
	}

	for _, redisItem := range redisItems {
		err := redisItem.Insert(gameRedisClient)
		if err != nil {
			return err
		}
	}

	return nil
}

func (redisItem *RedisItem) Insert(redisClient *redis.Client) error {
	switch redisItem.Type {
	case RedisImportTypeString:
		if err := redisClient.Set(redisItem.Key, redisItem.Value, 0).Err(); err != nil {
			return err
		}
	case RedisImportTypeHash:
		switch val := redisItem.Value.(type) {
		case map[string]interface{}:
			for k, v := range val {
				switch str := v.(type) {
				case string:
					if err := redisClient.HSet(redisItem.Key, k, str).Err(); err != nil {
						return err
					}
				}
			}
		}
	case RedisImportTypeZset:
		switch val := redisItem.Value.(type) {
		case []interface{}:
			for _, v := range val {
				switch zset := v.(type) {
				case []interface{}:
					if len(zset) == 2 {
						zItem := redis.Z{}
						for _, part := range zset {
							switch t := part.(type) {
							case float64:
								zItem.Score = t
							case string:
								zItem.Member = t
							}
						}
						if err := redisClient.ZAdd(redisItem.Key, zItem).Err(); err != nil {
							return err
						}
						if redisItem.TTL > 0 {
							redisClient.Expire(redisItem.Key, time.Duration(redisItem.TTL))
						}
					}
				}
			}
		}
	case RedisImportTypeList:
		switch val := redisItem.Value.(type) {
		case []interface{}:
			for _, v := range val {
				switch listItem := v.(type) {
				case string:
					if err := redisClient.LPush(redisItem.Key, listItem).Err(); err != nil {
						return err
					}
				}
			}
		}
	}

	return nil
}
